Might want to add an options void pointer to SocketOpen.
Will eventually need to change the file descriptor from an in to a struct, probably.

LinuxSocket should be a wrapper around the Socket module.
We'll somehow tell Socket to use UnixSocket.
    Socket will contain function pointers:
        Open
        Close
        Bind
        Etc
    We'll populate these accordingly, either with mock functions or with real ones.
    We can test the Socket module with mock functions.
    The Linux Socket will populate Socket with UnixSocket functions.
    This will remove Socket's dependency on UnixSocket.

Remove the dependency of TestSocket on UnixSocket.

Split SocketClient and SocketServer.
    Should the Server have its own struct? I don't think so. Why should it?
    Should we prevent client functions from being called on a Server or Client? No?
    Should we rename functions to be specific? Not yet.
    Should Socket.h include SocketServer.h and SocketClient.h? For now.

Move SocketOptions to UnixSocket.

Figure out why test Socket.o files conflict with production .o files and how to fix it.
    If test code is run first, cpputest_calloc_location() and cpputest_free_location() are undefined.
    If production code is run first, these function are not inserted so memory leak checks will never fail. Silent and deadly.

Document return values in Socket.h.
Can Socket_Close() fail?

Add is_connected flag?

Should a bind with a null address bind to any address? Maybe so, but work through the entire example first.

Should the backlog be part of the Socket struct?

I'm being inconsistent with return values between UnixSocket and Socket modules.

Add options for flags to Socket_Send().

Remove MSG_NOSIGNAL and allow the user to customize how to handle SIGPIPE errors.

Add a name to each Socket struct.
